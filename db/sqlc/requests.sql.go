// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: requests.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRequest = `-- name: CreateRequest :one
INSERT INTO requests (
  title, status, amount, paid_to_id, createdby_id, approvedby_id
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at
`

type CreateRequestParams struct {
	Title        string         `json:"title"`
	Status       ApprovalStatus `json:"status"`
	Amount       int64          `json:"amount"`
	PaidToID     int64          `json:"paid_to_id"`
	CreatedbyID  uuid.UUID      `json:"createdby_id"`
	ApprovedbyID uuid.UUID      `json:"approvedby_id"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, createRequest,
		arg.Title,
		arg.Status,
		arg.Amount,
		arg.PaidToID,
		arg.CreatedbyID,
		arg.ApprovedbyID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE 
FROM requests 
WHERE id = $1
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const getRequest = `-- name: GetRequest :one
SELECT id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at FROM requests
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRequest(ctx context.Context, id int64) (Request, error) {
	row := q.db.QueryRowContext(ctx, getRequest, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const getRequests = `-- name: GetRequests :many
SELECT id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at FROM requests 
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetRequests(ctx context.Context, arg GetRequestsParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Amount,
			&i.PaidToID,
			&i.CreatedbyID,
			&i.ApprovedbyID,
			&i.CreatedAt,
			&i.ApprovedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequest = `-- name: UpdateRequest :one
UPDATE requests 
SET
  title = COALESCE($1,title),
  status = COALESCE($2,status),
  amount = COALESCE($3,amount),
  paid_to_id = COALESCE($4,paid_to_id),
  approvedby_id = COALESCE($5,approvedby_id),
  approved_at = COALESCE($6,approved_at)
WHERE id = $7
RETURNING id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at
`

type UpdateRequestParams struct {
	Title        sql.NullString     `json:"title"`
	Status       NullApprovalStatus `json:"status"`
	Amount       sql.NullInt64      `json:"amount"`
	PaidToID     sql.NullInt64      `json:"paid_to_id"`
	ApprovedbyID uuid.NullUUID      `json:"approvedby_id"`
	ApprovedAt   sql.NullTime       `json:"approved_at"`
	ID           int64              `json:"id"`
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, updateRequest,
		arg.Title,
		arg.Status,
		arg.Amount,
		arg.PaidToID,
		arg.ApprovedbyID,
		arg.ApprovedAt,
		arg.ID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}
