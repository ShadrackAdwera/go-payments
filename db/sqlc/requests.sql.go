// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: requests.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createRequest = `-- name: CreateRequest :one
INSERT INTO requests (
  title, status, amount, paid_to_id, createdby_id, approvedby_id
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at
`

type CreateRequestParams struct {
	Title        string         `json:"title"`
	Status       ApprovalStatus `json:"status"`
	Amount       int64          `json:"amount"`
	PaidToID     int64          `json:"paid_to_id"`
	CreatedbyID  string         `json:"createdby_id"`
	ApprovedbyID string         `json:"approvedby_id"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, createRequest,
		arg.Title,
		arg.Status,
		arg.Amount,
		arg.PaidToID,
		arg.CreatedbyID,
		arg.ApprovedbyID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE 
FROM requests 
WHERE id = $1
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const getRequest = `-- name: GetRequest :one
SELECT id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at FROM requests
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRequest(ctx context.Context, id int64) (Request, error) {
	row := q.db.QueryRowContext(ctx, getRequest, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const getRequests = `-- name: GetRequests :many
SELECT requests.id, title, status, amount, paid_to_id, requests.createdby_id, approvedby_id, created_at, approved_at, clients.id, name, email, phone, account_number, preferred_payment_type, clients.createdby_id FROM requests 
JOIN clients ON requests.paid_to_id = clients.id
ORDER BY requests.id
LIMIT $1
OFFSET $2
`

type GetRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRequestsRow struct {
	ID                   int64          `json:"id"`
	Title                string         `json:"title"`
	Status               ApprovalStatus `json:"status"`
	Amount               int64          `json:"amount"`
	PaidToID             int64          `json:"paid_to_id"`
	CreatedbyID          string         `json:"createdby_id"`
	ApprovedbyID         string         `json:"approvedby_id"`
	CreatedAt            time.Time      `json:"created_at"`
	ApprovedAt           time.Time      `json:"approved_at"`
	ID_2                 int64          `json:"id_2"`
	Name                 string         `json:"name"`
	Email                string         `json:"email"`
	Phone                string         `json:"phone"`
	AccountNumber        sql.NullString `json:"account_number"`
	PreferredPaymentType PaymentTypes   `json:"preferred_payment_type"`
	CreatedbyID_2        string         `json:"createdby_id_2"`
}

func (q *Queries) GetRequests(ctx context.Context, arg GetRequestsParams) ([]GetRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsRow
	for rows.Next() {
		var i GetRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Amount,
			&i.PaidToID,
			&i.CreatedbyID,
			&i.ApprovedbyID,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ID_2,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.AccountNumber,
			&i.PreferredPaymentType,
			&i.CreatedbyID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsToApprove = `-- name: GetRequestsToApprove :many
SELECT requests.id, title, status, amount, paid_to_id, requests.createdby_id, approvedby_id, created_at, approved_at, clients.id, name, email, phone, account_number, preferred_payment_type, clients.createdby_id FROM requests
JOIN clients ON requests.paid_to_id = clients.id 
WHERE status = $1
AND approvedby_id = $2
ORDER BY requests.created_at DESC
`

type GetRequestsToApproveParams struct {
	Status       ApprovalStatus `json:"status"`
	ApprovedbyID string         `json:"approvedby_id"`
}

type GetRequestsToApproveRow struct {
	ID                   int64          `json:"id"`
	Title                string         `json:"title"`
	Status               ApprovalStatus `json:"status"`
	Amount               int64          `json:"amount"`
	PaidToID             int64          `json:"paid_to_id"`
	CreatedbyID          string         `json:"createdby_id"`
	ApprovedbyID         string         `json:"approvedby_id"`
	CreatedAt            time.Time      `json:"created_at"`
	ApprovedAt           time.Time      `json:"approved_at"`
	ID_2                 int64          `json:"id_2"`
	Name                 string         `json:"name"`
	Email                string         `json:"email"`
	Phone                string         `json:"phone"`
	AccountNumber        sql.NullString `json:"account_number"`
	PreferredPaymentType PaymentTypes   `json:"preferred_payment_type"`
	CreatedbyID_2        string         `json:"createdby_id_2"`
}

func (q *Queries) GetRequestsToApprove(ctx context.Context, arg GetRequestsToApproveParams) ([]GetRequestsToApproveRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsToApprove, arg.Status, arg.ApprovedbyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsToApproveRow
	for rows.Next() {
		var i GetRequestsToApproveRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Amount,
			&i.PaidToID,
			&i.CreatedbyID,
			&i.ApprovedbyID,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ID_2,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.AccountNumber,
			&i.PreferredPaymentType,
			&i.CreatedbyID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequest = `-- name: UpdateRequest :one
UPDATE requests 
SET
  title = COALESCE($1,title),
  status = COALESCE($2,status),
  amount = COALESCE($3,amount),
  paid_to_id = COALESCE($4,paid_to_id),
  approvedby_id = COALESCE($5,approvedby_id),
  approved_at = COALESCE($6,approved_at)
WHERE id = $7
RETURNING id, title, status, amount, paid_to_id, createdby_id, approvedby_id, created_at, approved_at
`

type UpdateRequestParams struct {
	Title        sql.NullString     `json:"title"`
	Status       NullApprovalStatus `json:"status"`
	Amount       sql.NullInt64      `json:"amount"`
	PaidToID     sql.NullInt64      `json:"paid_to_id"`
	ApprovedbyID sql.NullString     `json:"approvedby_id"`
	ApprovedAt   sql.NullTime       `json:"approved_at"`
	ID           int64              `json:"id"`
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, updateRequest,
		arg.Title,
		arg.Status,
		arg.Amount,
		arg.PaidToID,
		arg.ApprovedbyID,
		arg.ApprovedAt,
		arg.ID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Amount,
		&i.PaidToID,
		&i.CreatedbyID,
		&i.ApprovedbyID,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}
